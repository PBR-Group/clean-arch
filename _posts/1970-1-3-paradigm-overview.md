---
layout: post
title: مروری بر پارادایم‌ها
chapter: بخش دوم - فصل سوم
author: فهیمه زیودار
---

این سه پارادایم که در این فصل مرور می‌شوند، برنامه‌نویسی ساختاری (ساخت محور)، برنامه‌نویسی شی‌گرا و برنامه‌نویسی تابعی(عملکردی ) هستند.

<h4>برنامه نویسی ساختاری </h4>
اولین پارادایمی که پذیرفته شد (ولی اولین نبود که اختراع شد ).
که توسط Edsger Wybe Dijkstra در سال 1968 کشف شد.  Dijkstra نشان داد که استفاده از پرش‌های نامحدود (goto statements) برای ساختار برنامه مضر است.
به طور خلاصه اگر بخواهیم بگوییم :
در واقع برنامه نویسی ساختاری روی انتقال مستقیم کنترل تاکید می‌کند.

<h4>برنامه نویسی شیءگرا </h4>
پارادایم دومی که پذیرفته شد سال 1996 توسط Ole Johan Dahl and Kristen Nygaard  کشف شد.
این دو برنامه نویس  متوجه شدند که میتوان call stack frame تابع در زبان AGOAL را به حافظه‌ی Heap انتقال داد. در نتیجه اجازه میدهد که متغیرهای محلی تابع، حتی بعد از بازگشت تابع هم از بین نروند.  تابع تبدیل به سازنده برای یک کلاس شد،متغیرهای محلی instance variable شدند و توابع تودرتو به method تبدیل شدند. این امر به طور اجتناب‌ناپذیری منجر به کشف پلی مورفیسم از طریق استفاده از function pointer شد.
می‌توانیم الگوی برنامه‌نویسی شی گرا را به شکل زیر خلاصه کنیم:
برنامه‌نویسی شی گرا بری روی انتقال غیر مستقیم کنترل تاکید می‌کند.

 
<h4>برنامه نویسی فانکشنال </h4>
پارادایم سوم با اینکه خیلی وقت پیش اختراع شده بود ولی اخیرا استفاده میشود. برنامه‌نویسی فانکشنال را از نتیجه کار Alonzo درست کردند.

  که در سال ۱۹۳۶ حساب دیفرانسیل و انتگرال را اختراع کرد در حالی که همان مشکل ریاضی را که آلن تورینگ را در همان زمان انگیزه می‌داد. جبر او بنیان زبان LISP است که در سال ۱۹۵۸ توسط جان مک‌کارتی اختراع شد.یک مفهوم اساسی از حساب دیفرانسیل و انتگرال، immutability است - یعنی، اینت صور که مقادیر نماد تغییر نمی‌کنند. این به طور موثر به این معنی است که یک زبان تابعی یک بیانیه تخصیص ندارد. بیشتر زبان‌های تابعی، در واقع ابزارهایی برای تغییر ارزش یک متغیر دارند، اما فقط تحت انضباط بسیار دقیق.
ما می‌توانیم الگوی برنامه‌نویسی تابعی را به شکل زیر خلاصه کنیم:
برنامه‌نویسی تابعی، نظم را بر تکلیف تحمیل می‌کند.


<h4>غذای فکر</h4>
Uncle bob این سه پارادایم رو عمدا معرفی کرده. هر یک از پارادایم ها یکی از توانایی ها برنامه نویسی رو حذف میکنند، هیچ کدوم از این پارادایم ها توانایی جدید اضافه نمیکنن. در واقع پارادایم ها به ما میگن چه کاری رو انجام ندیم، بیش از اینکه بگن کاری انجام بدیم. بهترین راه برای نگاه ب مسئله اینه که ببینیم هر پارادایم چه چیزی رو از ما میگیره. این سه پارادایم در کنار هم goto statements , function pointers , and assignment رو حذف میکنند.

احتمالا پارادایم جدید منفی (ویژگی خاصی را حذف کند) دیگری به وجود نمی‌آید. شواهد هم این را نشان داده، این سه پارادایم توی ده سال کشف شدند و بعد از آن پارادایم جدیدی به وجود نیامده است.

<h4>نتیجه‌گیری</h4>
خب حالا این  درس تاریخ پارادایم‌ها  چه ارتباطی به معماری دارد ؟
همه چیز. ما از پلی مورفیسم به عنوان یه مکانیزم برای عبور از مرزهای معماری استفاده می کنیم .
(توانایی ظاهر شدن یک شی در چندین قالب رو پولی مورفیسم میگن.)
ما از برنامه نویسی فانکشنال برای موقعیت و دسترسی به داده ها استفاده می کنیم و از برنامه نویسی ساختاری به عنوان پایه الگوریتمی ماژول هامون استفاده می کنیم.
توجه داشته باشید که این سه پارادایم با سه مساله بزرگ معماری انطباق دارند:function,  separation of concern و data managment.